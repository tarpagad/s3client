To manually enable stateless mode, you need to configure cookieCache and account with the following options:

auth.ts

import { betterAuth } from "better-auth"
export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 7 * 24 * 60 * 60, // 7 days cache duration
            strategy: "jwe", // can be "jwt" or "compact"
            refreshCache: true, // Enable stateless refresh
        },
    },
    account: {
        storeStateStrategy: "cookie",
        storeAccountCookie: true, // Store account data after OAuth flow in a cookie (useful for database-less flows)
    }
});
If you don't provide a database, by default we provide the above configuration for you.

Understanding refreshCache
The refreshCache option controls automatic cookie refresh before expiry without querying any database:

false (default): No automatic refresh. When the cookie cache expires (reaches maxAge), it will attempt to fetch from the database if available.
true: Enable automatic refresh with default settings. Refreshes when 80% of maxAge is reached (20% time remaining).
object: Custom refresh configuration with updateAge property.
auth.ts

export const auth = betterAuth({
    session: {
        cookieCache: {
            enabled: true,
            maxAge: 300, // 5 minutes
            refreshCache: {
                updateAge: 60 // Refresh when 60 seconds remain before expiry
            }
        }
    }
});
Versioning Stateless Sessions
One of the biggest drawbacks of stateless sessions is that you can't invalidate session easily. To solve this with better auth, if you would like to invalidate all sessions, you can change the version of the cookie cache and re-deploy your application.

auth.ts

export const auth = betterAuth({
    session: {
        cookieCache: {
            version: "2", // Change the version to invalidate all sessions
        }
    }
});
This will invalidate all sessions that don't match the new version.

Stateless with Secondary Storage
You can combine stateless sessions with secondary storage (Redis, etc.) for the best of both worlds:

auth.ts

import { betterAuth } from "better-auth"
import { redis } from "./redis"
export const auth = betterAuth({
    // No primary database needed
    secondaryStorage: {
        get: async (key) => await redis.get(key),
        set: async (key, value, ttl) => await redis.set(key, value, "EX", ttl),
        delete: async (key) => await redis.del(key)
    },
    session: {
        cookieCache: {
            maxAge: 5 * 60, // 5 minutes (short-lived cookie)
            refreshCache: false // Disable stateless refresh
        }
    }
});
This setup:

Uses cookies for session validation (no DB queries)
Uses Redis for storing session data and refreshing the cookie cache before expiry
You can revoke sessions from the secondary storage and the cookie cache will be invalidated on refresh
Customizing Session Response
When you call getSession or useSession, the session data is returned as a user and session object. You can customize this response using the customSession plugin.

auth.ts

import { customSession } from "better-auth/plugins";
export const auth = betterAuth({
    plugins: [
        customSession(async ({ user, session }) => {
            const roles = findUserRoles(session.session.userId);
            return {
                roles,
                user: {
                    ...user,
                    newField: "newField",
                },
                session
            };
        }),
    ],
});
This will add roles and user.newField to the session response.

Infer on the Client

auth-client.ts

import { customSessionClient } from "better-auth/client/plugins";
import type { auth } from "@/lib/auth"; // Import the auth instance as a type
const authClient = createAuthClient({
    plugins: [customSessionClient<typeof auth>()],
});
const { data } = authClient.useSession();
const { data: sessionData } = await authClient.getSession();
// data.roles
// data.user.newField
Caveats on Customizing Session Response
The passed session object to the callback does not infer fields added by plugins.
However, as a workaround, you can pull up your auth options and pass it to the plugin to infer the fields.


import { betterAuth, BetterAuthOptions } from "better-auth";
const options = {
  //...config options
  plugins: [
    //...plugins 
  ]
} satisfies BetterAuthOptions;
export const auth = betterAuth({
    ...options,
    plugins: [
        ...(options.plugins ?? []),
        customSession(async ({ user, session }, ctx) => {
            // now both user and session will infer the fields added by plugins and your custom fields
            return {
                user,
                session
            }
        }, options), // pass options here
    ]
})
When your server and client code are in separate projects or repositories, and you cannot import the auth instance as a type reference, type inference for custom session fields will not work on the client side.
Session caching, including secondary storage or cookie cache, does not include custom fields. Each time the session is fetched, your custom session function will be called.
Mutating the list-device-sessions endpoint The /multi-session/list-device-sessions endpoint from the multi-session plugin is used to list the devices that the user is signed into.

You can mutate the response of this endpoint by passing the shouldMutateListDeviceSessionsEndpoint option to the customSession plugin.

By default, we do not mutate the response of this endpoint.

auth.ts

import { customSession } from "better-auth/plugins";
export const auth = betterAuth({
    plugins: [
        customSession(async ({ user, session }, ctx) => {
            return {
                user,
                session
            }
        }, {}, { shouldMutateListDeviceSessionsEndpoint: true }), 
    ],
});
